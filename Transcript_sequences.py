#!/usr/bin/env python
# usage: python Transcript_sequences.py -s L13_trimmed_Ath_M13_bt1.sam -p L13_untrimmed_Ath_M13_bt1.sam -ref M13mp18_Bayou.fa -out_s L13_short.txt -out_p L13_long.txt
# help: python Transcript_sequences.py -h
# This script assembles (merges) paired-end reads into RNA transcripts.
# It is especially useful if the RNA transcripts have lengths just around the read size (like RNA transcripts generated by AtPol IV and AtRDR2).
# In this scenario, we need paired-end sequencing to get full length transcripts, but the R1 and R2 reads usually overlap with each other.
# This script is used for Jasleen et al. (2019) paper
# Output file: assembled RNA transcripts
# Please contact Feng Wang (wangfeng@iu.edu) if you have any questions

import re
import subprocess
from Bio.Seq import Seq
import argparse
from pyfaidx import Fasta
import argparse


def aligned_reads(input_sam, output): #Get transcript sequences from 'single-ended' reads (trimmed reads)
	with open(output,'w') as f2:
		with open(input_sam,'rb') as f1:
			for line in f1:
				if not line.startswith("@"):
					alignment = line.strip().split('\t')
					ID = alignment[0]
					flag = alignment[1]
					if flag == '0':
						sequence = alignment[9]
						size = len(sequence)
						f2.write('%s\t%s\t%d\t%s\n' %(ID, sequence, size, "forward"))
					elif flag == '16':
						sequence = Seq(alignment[9]).reverse_complement()
						size = len(sequence)
						f2.write('%s\t%s\t%d\t%s\n' %(ID, sequence, size, "reverse"))
					else:
						continue



def aligned_long_reads(input_sam_file, reference, output): #Get transcript sequences from 'paired-ended' reads, reference genome required
	ref = Fasta(reference)
	with open(output,'w') as f2:
		with open(input_sam_file,'rb') as f1:
			for line in f1:
				if not line.startswith("@"):
					alignment = line.strip().split('\t')
					ID = alignment[0]
					FLAG = alignment[1]
					chromesome = alignment[2]
					left = int(alignment[3])
					Read_length = len(alignment[9])
					PE_size = int(alignment[8])
					Read = Seq(alignment[9])
					if FLAG == "99":
						first_sequence = Read
						next_alignment = f1.next().strip().split('\t')
						next_ID = next_alignment[0]
						next_FLAG = next_alignment[1]
						next_sequence = Seq(next_alignment[9])
						next_MDZ = next_alignment[12].split(':')[-1]
						if next_ID == ID and next_FLAG == "147":
							if PE_size <= 160:
								head_length = tail_length = PE_size - 80
								shared_length = 160 - PE_size
								if first_sequence[80 - shared_length:80] == next_sequence[0:shared_length]:
									sequence = first_sequence[0:head_length] + next_sequence
								else:
									continue
							else:
								gap = PE_size - 160
								sequence = first_sequence + Seq(ref[chromesome][left-1 + 80: left-1 + 80 + gap].seq) + next_sequence
							size = len(sequence)
							f2.write('%s\t%s\t%d\t%s\n' %(ID, sequence, size, "forward"))
						else:
							continue
					elif FLAG == "163":
						first_sequence = Read						
						next_alignment = f1.next().strip().split('\t')
						next_ID = next_alignment[0]
						next_FLAG = next_alignment[1]
						next_sequence = Seq(next_alignment[9])
						if next_ID == ID and next_FLAG == "83":
							if PE_size <= 160:
								head_length = tail_length = PE_size - 80
								shared_length = 160 - PE_size
								if first_sequence[80 - shared_length:80] == next_sequence[0:shared_length]:
									sequence = (first_sequence[0:head_length] + next_sequence).reverse_complement()
								else:
									continue
							else:
								gap = PE_size - 160
								sequence = (first_sequence + Seq(ref[chromesome][left-1 + 80: left-1 + 80 + gap].seq) + next_sequence).reverse_complement()
							size = len(sequence)
							f2.write('%s\t%s\t%d\t%s\n' %(ID, sequence, size, "reverse"))
						else:
							continue


def combine_file(short_seq, long_seq, output):
	file_names = [short_seq, long_seq]
	with open(output,'w') as f:
		for fname in file_names:
			with open (fname, 'r') as infile:
				for line in infile:
					f.write(line)


def uniq_seq(input, output):
	uniq_seq = {}
	uniq_seq['forward'] = {}
	uniq_seq['reverse'] = {}
	with open(input,'r') as f:
		for line in f:
			info = line.strip().split('\t')
			seq = info[1]
			direction = info[3]
			if seq not in uniq_seq[direction]:
				uniq_seq[direction][seq] = None
			else:
				continue

	with open (output, 'w') as f:
		for direction in uniq_seq:
			for seq in uniq_seq[direction]:
				f.write('%s\t%s\n' % (seq, direction))



if __name__ == '__main__':
	parser = argparse.ArgumentParser()
	parser.add_argument('-s',
		help="alignment file (SAM) with trimmed reads",
		dest='single')
	parser.add_argument('-p',
		help="alignment file (SAM) with untrimmed (paired) reads",
		dest='paired')
	parser.add_argument('-ref',
		help="reference genome (M13mp18_Bayou.fa)",
		dest='ref')
	parser.add_argument('-out_s',
		help="output sequences from trimmed reads",
		dest='out_single')
	parser.add_argument('-out_p',
		help="output sequences from untrimmed reads",
		dest='out_paired')
	args=parser.parse_args()

	if args.single and args.paired:
		aligned_reads(args.single, args.out_single)
		aligned_long_reads(args.paired, args.ref, args.out_paired)
		combine_file(args.out_single, args.out_paired, 'transcripts.txt')
		uniq_seq('transcripts.txt', 'Unique_transcripts.txt')
	else:
		if args.single:
			aligned_reads(args.single, args.out_single)
		elif args.paired:
			aligned_long_reads(args.paired, args.ref, args.out_paired)









